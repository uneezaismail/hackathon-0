# Data Model: Gold Tier AI Employee

**Date**: 2026-01-27
**Feature**: Gold Tier AI Employee
**Purpose**: Define entities, state transitions, and data contracts for Gold tier

## Overview

This document defines the data model for Gold Tier AI Employee, extending Silver tier with Odoo accounting entities, social media entities, autonomous task entities, and CEO briefing entities.

---

## Inherited Entities (Bronze + Silver Tier)

### From Bronze Tier
- **Action Item**: Created by watchers in /Needs_Action/
- **Plan**: Generated by needs-action-triage skill in /Plans/
- **Dashboard**: System status in Dashboard.md

### From Silver Tier
- **Approval Request**: HITL approval in /Pending_Approval/
- **Approved Action**: Approved items in /Approved/
- **Execution Record (Done)**: Completed actions in /Done/
- **Execution Record (Failed)**: Failed actions in /Failed/
- **Audit Log Entry**: External actions in /Logs/YYYY-MM-DD.json

---

## New Gold Tier Entities

### 1. Invoice (Odoo)

**Location**: Odoo database (accessed via odoo_mcp.py)
**Lifecycle**: Created → Validated → Sent → Paid
**Format**: Odoo account.move record

#### Schema

```python
from pydantic import BaseModel, Field
from datetime import date
from typing import List, Optional

class InvoiceLine(BaseModel):
    product_name: str = Field(description="Product/service name")
    description: str = Field(description="Line item description")
    quantity: float = Field(ge=0, description="Quantity")
    unit_price: float = Field(ge=0, description="Price per unit")
    subtotal: float = Field(ge=0, description="Line total")

class Invoice(BaseModel):
    invoice_id: str = Field(description="Odoo invoice ID (e.g., INV/2026/0001)")
    customer_name: str = Field(description="Customer name")
    customer_email: str = Field(description="Customer email for sending")
    invoice_date: date = Field(description="Invoice date")
    due_date: date = Field(description="Payment due date")
    lines: List[InvoiceLine] = Field(description="Invoice line items")
    subtotal: float = Field(ge=0, description="Subtotal before tax")
    tax_amount: float = Field(ge=0, description="Tax amount")
    total_amount: float = Field(ge=0, description="Total amount due")
    status: str = Field(description="draft | posted | sent | paid | overdue")
    payment_status: str = Field(description="not_paid | partial | paid")
    created_at: str = Field(description="ISO8601 timestamp")
    sent_at: Optional[str] = Field(None, description="ISO8601 timestamp when sent")
    paid_at: Optional[str] = Field(None, description="ISO8601 timestamp when paid")
```

#### Validation Rules

- `invoice_id` MUST follow Odoo sequence pattern (INV/YYYY/####)
- `total_amount` MUST equal subtotal + tax_amount
- `status` transitions: draft → posted → sent → paid
- `due_date` MUST be >= invoice_date
- All financial operations require HITL approval

#### State Transitions

```
Draft → Posted (validated) → Sent (emailed) → Paid (payment received)
                                           ↓
                                        Overdue (past due_date)
```

---

### 2. Payment (Odoo)

**Location**: Odoo database (accessed via odoo_mcp.py)
**Lifecycle**: Created → Posted → Reconciled
**Format**: Odoo account.payment record

#### Schema

```python
class Payment(BaseModel):
    payment_id: str = Field(description="Odoo payment ID (e.g., PAY/2026/0001)")
    payment_type: str = Field(description="inbound | outbound")
    customer_name: str = Field(description="Customer/vendor name")
    amount: float = Field(ge=0, description="Payment amount")
    payment_date: date = Field(description="Payment date")
    payment_method: str = Field(description="bank_transfer | credit_card | cash | check")
    reference: str = Field(description="Payment reference/memo")
    invoice_id: Optional[str] = Field(None, description="Related invoice ID")
    status: str = Field(description="draft | posted | reconciled")
    created_at: str = Field(description="ISO8601 timestamp")
    reconciled_at: Optional[str] = Field(None, description="ISO8601 timestamp when reconciled")
```

#### Validation Rules

- `payment_type` MUST be inbound (customer payment) or outbound (vendor payment)
- `amount` MUST be > 0
- `payment_date` MUST be <= today
- Reconciliation MUST match payment to invoice
- All payment operations require HITL approval

---

### 3. Expense (Odoo)

**Location**: Odoo database (accessed via odoo_mcp.py)
**Lifecycle**: Created → Submitted → Approved → Posted
**Format**: Odoo hr.expense record

#### Schema

```python
class Expense(BaseModel):
    expense_id: str = Field(description="Odoo expense ID (e.g., EXP/2026/0001)")
    description: str = Field(description="Expense description")
    category: str = Field(description="Expense category (office_supplies, travel, meals, etc.)")
    amount: float = Field(ge=0, description="Expense amount")
    expense_date: date = Field(description="Date of expense")
    vendor: Optional[str] = Field(None, description="Vendor name")
    receipt_path: Optional[str] = Field(None, description="Path to receipt file")
    status: str = Field(description="draft | submitted | approved | posted")
    created_at: str = Field(description="ISO8601 timestamp")
    approved_at: Optional[str] = Field(None, description="ISO8601 timestamp when approved")
```

#### Validation Rules

- `category` MUST be valid expense category from Odoo configuration
- `amount` MUST be > 0
- `expense_date` MUST be <= today
- Receipt attachment recommended for amounts > $50
- Expense categorization may be automated based on Company_Handbook.md rules

---

### 4. Social Media Post

**Location**: Platform APIs (Facebook, Instagram, Twitter) + vault metadata
**Lifecycle**: Created → Approved → Published → Tracked
**Format**: Markdown file in /Done/ with platform IDs

#### Schema

```python
class SocialMediaPost(BaseModel):
    post_id: str = Field(description="Internal post ID")
    platforms: List[str] = Field(description="facebook | instagram | twitter")
    content: str = Field(description="Post content (adapted per platform)")
    platform_specific_content: dict = Field(description="Platform-specific versions")
    media_paths: Optional[List[str]] = Field(None, description="Paths to media files")
    scheduled_time: Optional[str] = Field(None, description="ISO8601 timestamp for scheduling")
    status: str = Field(description="draft | pending_approval | approved | published | failed")
    platform_ids: dict = Field(description="Platform-specific post IDs")
    created_at: str = Field(description="ISO8601 timestamp")
    published_at: Optional[str] = Field(None, description="ISO8601 timestamp when published")
    engagement_metrics: Optional[dict] = Field(None, description="Engagement data")

class PlatformContent(BaseModel):
    facebook: Optional[str] = Field(None, description="Facebook version (no char limit)")
    instagram: Optional[str] = Field(None, description="Instagram version (2200 char limit)")
    twitter: Optional[str] = Field(None, description="Twitter version (280 char limit)")

class EngagementMetrics(BaseModel):
    impressions: int = Field(ge=0, description="Total impressions")
    reach: int = Field(ge=0, description="Unique users reached")
    likes: int = Field(ge=0, description="Likes/reactions")
    comments: int = Field(ge=0, description="Comments")
    shares: int = Field(ge=0, description="Shares/retweets")
    engagement_rate: float = Field(ge=0, le=1, description="Engagement rate (0-1)")
```

#### Validation Rules

- `platforms` MUST contain at least one platform
- `content` MUST be adapted for each platform's character limits
- Twitter: 280 characters max
- Instagram: 2200 characters max
- Facebook: No limit but recommend < 500 characters for engagement
- All social media posts require HITL approval per Company_Handbook.md rules

---

### 5. Business Briefing

**Location**: `My_AI_Employee/AI_Employee_Vault/Briefings/`
**Lifecycle**: Generated weekly → Reviewed by user
**Format**: Markdown file with structured sections

#### Schema

```python
class BusinessBriefing(BaseModel):
    briefing_id: str = Field(description="Briefing ID (e.g., BRIEF-2026-W04)")
    week_start: date = Field(description="Week start date (Monday)")
    week_end: date = Field(description="Week end date (Sunday)")
    generated_at: str = Field(description="ISO8601 timestamp")
    executive_summary: str = Field(description="200-300 word summary")
    revenue_analysis: RevenueAnalysis
    completed_tasks: List[TaskSummary]
    bottlenecks: List[Bottleneck]
    expense_analysis: ExpenseAnalysis
    proactive_suggestions: List[Suggestion]
    social_media_performance: SocialMediaSummary
    upcoming_deadlines: List[Deadline]

class RevenueAnalysis(BaseModel):
    total_revenue: float = Field(description="Total revenue for week")
    revenue_vs_target: float = Field(description="Percentage vs target")
    invoices_sent: int = Field(description="Number of invoices sent")
    invoices_paid: int = Field(description="Number of invoices paid")
    outstanding_amount: float = Field(description="Total outstanding receivables")
    aged_receivables: dict = Field(description="Aged receivables breakdown")

class TaskSummary(BaseModel):
    task_count: int = Field(description="Number of tasks completed")
    categories: dict = Field(description="Tasks by category")
    avg_completion_time: float = Field(description="Average completion time in hours")

class Bottleneck(BaseModel):
    description: str = Field(description="Bottleneck description")
    impact: str = Field(description="high | medium | low")
    recommendation: str = Field(description="Suggested action")

class ExpenseAnalysis(BaseModel):
    total_expenses: float = Field(description="Total expenses for week")
    expenses_by_category: dict = Field(description="Expenses by category")
    unusual_expenses: List[str] = Field(description="Expenses requiring attention")

class Suggestion(BaseModel):
    type: str = Field(description="cost_saving | revenue_opportunity | process_improvement")
    description: str = Field(description="Suggestion description")
    estimated_impact: str = Field(description="Estimated financial impact")

class SocialMediaSummary(BaseModel):
    total_posts: int = Field(description="Total posts across platforms")
    total_reach: int = Field(description="Total reach across platforms")
    total_engagement: int = Field(description="Total engagement across platforms")
    top_performing_post: dict = Field(description="Best performing post")
    platform_breakdown: dict = Field(description="Metrics by platform")

class Deadline(BaseModel):
    description: str = Field(description="Deadline description")
    due_date: date = Field(description="Due date")
    priority: str = Field(description="high | medium | low")
```

#### Validation Rules

- Briefing generated every Sunday at 8:00 PM
- Data collected from last 7 days (Monday-Sunday)
- Executive summary MUST be 200-300 words
- All financial data sourced from Odoo
- Social media data sourced from platform APIs
- Proactive suggestions MUST include estimated impact

---

### 6. Autonomous Task

**Location**: State file (`.ralph_state.json`) + vault metadata
**Lifecycle**: Started → Iterating → Completed | Max Iterations Reached
**Format**: JSON state file

#### Schema

```python
class AutonomousTask(BaseModel):
    task_id: str = Field(description="Task ID")
    description: str = Field(description="Task description")
    task_file_path: str = Field(description="Path to task file in vault")
    status: str = Field(description="running | completed | max_iterations | failed")
    iteration: int = Field(ge=0, description="Current iteration count")
    max_iterations: int = Field(ge=1, description="Maximum iterations allowed")
    start_time: str = Field(description="ISO8601 timestamp")
    last_iteration_time: str = Field(description="ISO8601 timestamp")
    completion_time: Optional[str] = Field(None, description="ISO8601 timestamp")
    completion_signal: str = Field(description="file_moved_to_done | max_iterations | error")
```

#### Validation Rules

- `max_iterations` default: 10 (configurable via RALPH_MAX_ITERATIONS env var)
- `iteration` increments after each Claude Code exit
- Task complete when file moves to /Done/ folder
- State persisted after each iteration for crash recovery
- Stop hook checks completion signal and re-injects prompt if not complete

---

### 7. Audit Log Entry (Enhanced for Gold Tier)

**Location**: `My_AI_Employee/AI_Employee_Vault/Logs/YYYY-MM-DD.json`
**Lifecycle**: Created on external action → Retained 90 days
**Format**: JSONL (one JSON object per line)

#### Schema (Extended from Silver Tier)

```python
class AuditLogEntry(BaseModel):
    timestamp: str = Field(description="ISO8601 timestamp")
    action_type: str = Field(description="send_email | create_post | create_invoice | record_payment | create_expense")
    actor: str = Field(description="system | user | autonomous_task")
    target: str = Field(description="Target of action (email, platform, customer)")
    approval_status: str = Field(description="approved | rejected | auto_approved")
    approved_by: Optional[str] = Field(None, description="User who approved")
    approved_at: Optional[str] = Field(None, description="ISO8601 timestamp")
    result: str = Field(description="success | failed | queued")
    error_message: Optional[str] = Field(None, description="Error details if failed")
    retry_count: int = Field(ge=0, description="Number of retry attempts")
    execution_time_ms: int = Field(ge=0, description="Execution time in milliseconds")
    # Gold tier additions
    financial_amount: Optional[float] = Field(None, description="Amount for financial operations")
    platform: Optional[str] = Field(None, description="Social media platform")
    odoo_record_id: Optional[str] = Field(None, description="Odoo record ID")
    credentials_sanitized: bool = Field(True, description="Credentials sanitized flag")
```

#### Validation Rules

- All credentials MUST be sanitized before logging
- API keys: Show first 4 chars + *** (e.g., "sk-1234***")
- Passwords: Redact entirely ("***")
- Credit cards: Show last 4 digits only ("**** **** **** 1234")
- PII: Truncate emails ("user@*****.com")
- Retention: 90 days minimum, then archive for 2 years

---

## Entity Relationships

```
Action Item (Needs_Action)
    ↓
Approval Request (Pending_Approval) ← Company_Handbook.md rules
    ↓
Approved Action (Approved)
    ↓
MCP Server Execution
    ├─→ Invoice (Odoo) → Payment (Odoo)
    ├─→ Expense (Odoo)
    ├─→ Social Media Post (Facebook/Instagram/Twitter)
    └─→ Audit Log Entry (Logs/)
    ↓
Execution Record (Done/Failed)
    ↓
Business Briefing (weekly aggregation)
```

## State Transition Diagram

```
[Watcher] → [Needs_Action] → [Triage] → [Pending_Approval]
                                              ↓
                                         [Human Decision]
                                              ↓
                                         [Approved]
                                              ↓
                                    [Orchestrator + MCP]
                                    ↙        ↓        ↘
                            [Odoo MCP]  [Facebook]  [Twitter]
                                    ↘        ↓        ↙
                                         [Done/Failed]
                                              ↓
                                         [Audit Log]
                                              ↓
                                    [CEO Briefing (weekly)]
```

## Data Integrity Checks

1. **Duplicate Detection**: SHA256 hash of content for action items
2. **YAML Preservation**: All vault operations preserve frontmatter
3. **Audit Log Sanitization**: Credentials sanitized before writing
4. **Financial Reconciliation**: Payments matched to invoices in Odoo
5. **State Persistence**: Autonomous task state saved after each iteration
6. **Retention Policy**: Audit logs retained 90 days minimum

All entities follow Pydantic validation for type safety and data integrity.
