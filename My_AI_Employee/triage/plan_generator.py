"""
Plan generator for triage operations.

Generates plan content with checkboxes and done conditions based on
action items and handbook rules.
"""

from pathlib import Path
import logging
import frontmatter

from triage.handbook_reader import read_handbook_rules, extract_priority_rules


logger = logging.getLogger(__name__)


def generate_plan_content(
    action_item_post: frontmatter.Post,
    handbook_rules: str = None
) -> str:
    """
    Generate plan content with checkboxes and done condition.

    Args:
        action_item_post: The action item Post object
        handbook_rules: Optional handbook rules content

    Returns:
        Markdown content for the plan with checkboxes and done condition
    """
    # Extract action item details
    item_type = action_item_post.get('type', 'unknown')
    source_path = action_item_post.get('source_path', 'N/A')
    received = action_item_post.get('received', 'unknown')

    # Extract title from content
    content_lines = action_item_post.content.strip().split('\n')
    title = content_lines[0].strip('#').strip() if content_lines else "Untitled Action"

    # Determine priority based on content and handbook rules
    priority = determine_priority(action_item_post, handbook_rules)

    # Generate action checklist based on item type
    action_checklist = generate_action_checklist(item_type, action_item_post)

    # Generate done condition
    done_condition = generate_done_condition(item_type, action_item_post)

    # Build plan content
    plan_content = f"""# Plan: {title}

## Action Item Details
- **Type**: {item_type}
- **Priority**: {priority}
- **Source**: `{source_path}`
- **Received**: {received[:19] if len(received) > 19 else received}

## Analysis
{generate_analysis(action_item_post, handbook_rules)}

## Action Checklist
{action_checklist}

## Done Condition
{done_condition}

## Notes
- This plan was auto-generated by the Bronze Tier AI Employee triage system
- Review and modify as needed before execution
- Archive to Done/ when complete
"""

    return plan_content


def determine_priority(action_item_post: frontmatter.Post, handbook_rules: str = None) -> str:
    """
    Determine priority level for an action item.

    Args:
        action_item_post: The action item Post object
        handbook_rules: Optional handbook rules content

    Returns:
        Priority level: "High", "Medium", or "Low"
    """
    # Default priority
    priority = "Medium"

    # Check for explicit priority in metadata
    if 'priority' in action_item_post.metadata:
        return action_item_post.metadata['priority'].capitalize()

    # Analyze content for priority indicators
    content_lower = action_item_post.content.lower()

    high_priority_keywords = ['urgent', 'critical', 'asap', 'emergency', 'important']
    low_priority_keywords = ['routine', 'when possible', 'low priority', 'optional']

    if any(keyword in content_lower for keyword in high_priority_keywords):
        priority = "High"
    elif any(keyword in content_lower for keyword in low_priority_keywords):
        priority = "Low"

    # Check handbook rules if provided
    if handbook_rules:
        priority_rules = extract_priority_rules(handbook_rules)
        # Could implement more sophisticated priority determination here

    return priority


def generate_action_checklist(item_type: str, action_item_post: frontmatter.Post) -> str:
    """
    Generate action checklist based on item type.

    Args:
        item_type: Type of action item (file_drop, email, manual)
        action_item_post: The action item Post object

    Returns:
        Markdown checklist with checkboxes
    """
    if item_type == 'file_drop':
        source_path = action_item_post.get('source_path', 'unknown')
        checklist = f"""- [ ] Review file at: `{source_path}`
- [ ] Determine file type and purpose
- [ ] Extract key information or requirements
- [ ] Identify any actions needed
- [ ] Document findings
- [ ] Archive original file if needed
- [ ] Update dashboard with status"""

    elif item_type == 'email':
        checklist = """- [ ] Read email content thoroughly
- [ ] Identify sender and context
- [ ] Extract action items or requests
- [ ] Determine response requirements
- [ ] Draft response if needed
- [ ] Update relevant stakeholders
- [ ] Archive email thread"""

    elif item_type == 'manual':
        checklist = """- [ ] Review manual action request
- [ ] Clarify requirements if needed
- [ ] Break down into subtasks
- [ ] Execute each subtask
- [ ] Verify completion
- [ ] Document results
- [ ] Notify requester"""

    else:
        # Generic checklist for unknown types
        checklist = """- [ ] Review action item details
- [ ] Determine required actions
- [ ] Execute actions
- [ ] Verify completion
- [ ] Document results"""

    return checklist


def generate_done_condition(item_type: str, action_item_post: frontmatter.Post) -> str:
    """
    Generate done condition for the plan.

    Args:
        item_type: Type of action item
        action_item_post: The action item Post object

    Returns:
        Markdown description of done condition
    """
    done_condition = f"""This plan is considered **complete** when:

1. ✅ All checkboxes in the Action Checklist are marked as done
2. ✅ Results and findings are documented in this plan
3. ✅ Original action item is archived to `Done/` folder
4. ✅ Dashboard is updated to reflect completion

**Completion Criteria:**
- All required actions have been executed
- No outstanding questions or blockers remain
- Documentation is clear and complete
- Stakeholders are informed (if applicable)
"""

    return done_condition


def generate_analysis(action_item_post: frontmatter.Post, handbook_rules: str = None) -> str:
    """
    Generate analysis section for the plan.

    Args:
        action_item_post: The action item Post object
        handbook_rules: Optional handbook rules content

    Returns:
        Markdown analysis text
    """
    item_type = action_item_post.get('type', 'unknown')

    # Extract key information from content
    content = action_item_post.content
    content_preview = content[:200] + "..." if len(content) > 200 else content

    analysis = f"""**Item Type**: {item_type}

**Content Preview**:
{content_preview}

**Initial Assessment**:
- This action item requires review and processing
- Type indicates: {get_type_description(item_type)}
"""

    # Add handbook compliance note if rules provided
    if handbook_rules:
        analysis += "\n**Handbook Compliance**: Review actions against Company Handbook guidelines before execution\n"

    return analysis


def get_type_description(item_type: str) -> str:
    """
    Get description for an item type.

    Args:
        item_type: Type of action item

    Returns:
        Human-readable description
    """
    descriptions = {
        'file_drop': 'A file was detected in the watch folder and needs review',
        'email': 'An email was received and requires response or action',
        'manual': 'A manual action was requested by a user',
        'unknown': 'Type is not specified or recognized'
    }

    return descriptions.get(item_type, 'Unknown item type')


def validate_plan_content(plan_content: str) -> tuple[bool, str]:
    """
    Validate that generated plan content meets requirements.

    Args:
        plan_content: Generated plan content

    Returns:
        Tuple of (is_valid, error_message)
    """
    # Check for required sections
    required_sections = [
        '# Plan:',
        '## Action Item Details',
        '## Action Checklist',
        '## Done Condition'
    ]

    for section in required_sections:
        if section not in plan_content:
            return False, f"Missing required section: {section}"

    # Check for checkboxes
    if '- [ ]' not in plan_content:
        return False, "Plan must contain at least one checkbox"

    # Check for done condition
    if 'complete' not in plan_content.lower():
        return False, "Plan must define completion criteria"

    return True, ""


def generate_malformed_item_warning(action_item_path: Path, error: str) -> str:
    """
    Generate warning message for malformed action items.

    Args:
        action_item_path: Path to the malformed action item
        error: Error description

    Returns:
        Warning message for dashboard
    """
    warning = f"""⚠️ **Malformed Action Item Detected**

- **File**: `{action_item_path.name}`
- **Error**: {error}
- **Location**: `Needs_Action/{action_item_path.name}`
- **Action Required**: Manual review and correction needed

This item will remain in Needs_Action/ until the issue is resolved.
"""

    return warning
