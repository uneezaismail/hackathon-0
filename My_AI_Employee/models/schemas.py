"""
Pydantic models for Silver Tier AI Employee data structures.

These models ensure type safety and validation across the entire workflow:
- Action items created by watchers
- Plans generated by skills
- Approval requests for HITL workflow
- Execution results from MCP servers

All vault markdown files should conform to these schemas.
"""

from pydantic import BaseModel, Field, field_validator
from typing import Optional, Literal
from datetime import datetime
from enum import Enum


# ============================================================================
# ENUMS - Standardized values
# ============================================================================

class ActionType(str, Enum):
    """Types of actions that can be performed."""
    SEND_EMAIL = "send_email"
    POST_LINKEDIN = "post_linkedin"
    SEND_WHATSAPP = "send_whatsapp"
    BROWSER_ACTION = "browser_action"


class MCPServer(str, Enum):
    """Available MCP servers for action execution."""
    EMAIL = "email"
    LINKEDIN = "linkedin"
    BROWSER = "browser"


class Priority(str, Enum):
    """Priority levels for actions."""
    HIGH = "High"
    MEDIUM = "Medium"
    LOW = "Low"


class RiskLevel(str, Enum):
    """Risk levels for actions."""
    HIGH = "High"
    MEDIUM = "Medium"
    LOW = "Low"


class Status(str, Enum):
    """Status of action items and requests."""
    PENDING = "pending"
    PENDING_APPROVAL = "pending_approval"
    APPROVED = "approved"
    REJECTED = "rejected"
    EXECUTING = "executing"
    EXECUTED = "executed"
    FAILED = "failed"
    COMPLETED = "completed"


# ============================================================================
# ACTION ITEM MODEL - Created by watchers
# ============================================================================

class ActionItem(BaseModel):
    """
    Action item created by watchers (Gmail, LinkedIn, WhatsApp).
    Stored in Needs_Action/ folder.
    """

    # Required fields
    action_type: ActionType
    type: Literal["email", "linkedin", "whatsapp", "file"]
    priority: Priority
    risk_level: RiskLevel
    status: Status = Status.PENDING

    # Metadata
    received: datetime
    sender: str
    subject: str
    body: str

    # Optional fields
    source_path: Optional[str] = None
    approval_required: bool = True

    # Execution tracking
    executed_at: Optional[datetime] = None
    execution_result: Optional[str] = None
    last_error: Optional[str] = None
    retry_count: int = 0

    # Approval tracking
    approved_at: Optional[datetime] = None
    approved_by: Optional[str] = None
    rejected_at: Optional[datetime] = None
    rejected_by: Optional[str] = None
    rejection_reason: Optional[str] = None

    # Processing tracking
    processed: Optional[datetime] = None
    result: Optional[str] = None
    related_plan: Optional[str] = None
    related_approval: Optional[str] = None

    @field_validator('sender')
    @classmethod
    def validate_sender(cls, v):
        """Ensure sender is not empty."""
        if not v or len(v.strip()) == 0:
            raise ValueError('Sender cannot be empty')
        return v

    @field_validator('subject')
    @classmethod
    def validate_subject(cls, v):
        """Ensure subject is not empty."""
        if not v or len(v.strip()) == 0:
            raise ValueError('Subject cannot be empty')
        return v


# ============================================================================
# APPROVAL REQUEST MODEL - Created by skills
# ============================================================================

class ApprovalRequest(BaseModel):
    """
    Approval request for HITL workflow.
    Stored in Pending_Approval/ or Approved/ folder.
    """

    # Required fields
    action_type: ActionType
    mcp_server: MCPServer
    priority: Priority
    risk_level: RiskLevel
    status: Status

    # Email-specific fields (required if action_type='send_email')
    recipient: Optional[str] = None
    subject: Optional[str] = None
    body: Optional[str] = None
    cc: Optional[str] = None
    bcc: Optional[str] = None

    # LinkedIn-specific fields
    post_content: Optional[str] = None
    post_url: Optional[str] = None

    # WhatsApp-specific fields
    whatsapp_recipient: Optional[str] = None
    whatsapp_message: Optional[str] = None

    # Metadata
    created_at: datetime
    approved_at: Optional[datetime] = None
    approved_by: Optional[str] = None
    rejected_at: Optional[datetime] = None
    rejected_by: Optional[str] = None
    rejection_reason: Optional[str] = None

    # References
    original_file: str
    plan_file: str
    entry_id: Optional[str] = None

    # Execution tracking
    executed_at: Optional[datetime] = None
    execution_result: Optional[str] = None
    execution_time_seconds: Optional[float] = None
    success: Optional[bool] = None
    error: Optional[str] = None
    retry_count: int = 0

    @field_validator('recipient')
    @classmethod
    def validate_recipient_for_email(cls, v, info):
        """Ensure recipient is provided for email actions."""
        if info.data.get('action_type') == ActionType.SEND_EMAIL and not v:
            raise ValueError('recipient is required for send_email actions')
        return v

    @field_validator('subject')
    @classmethod
    def validate_subject_for_email(cls, v, info):
        """Ensure subject is provided for email actions."""
        if info.data.get('action_type') == ActionType.SEND_EMAIL and not v:
            raise ValueError('subject is required for send_email actions')
        return v

    @field_validator('body')
    @classmethod
    def validate_body_for_email(cls, v, info):
        """Ensure body is provided for email actions."""
        if info.data.get('action_type') == ActionType.SEND_EMAIL and not v:
            raise ValueError('body is required for send_email actions')
        return v

    @field_validator('post_content')
    @classmethod
    def validate_post_content_for_linkedin(cls, v, info):
        """Ensure post_content is provided for LinkedIn actions."""
        if info.data.get('action_type') == ActionType.POST_LINKEDIN and not v:
            raise ValueError('post_content is required for post_linkedin actions')
        return v

    def to_markdown(self) -> str:
        """
        Convert to markdown format for vault storage.
        Generates properly formatted approval request file.
        """
        # Build frontmatter
        frontmatter = f"""---
action_type: {self.action_type.value}
mcp_server: {self.mcp_server.value}
priority: {self.priority.value}
risk_level: {self.risk_level.value}
status: {self.status.value}
created_at: {self.created_at.isoformat()}
original_file: {self.original_file}
plan_file: {self.plan_file}
"""

        # Add action-specific fields
        if self.action_type == ActionType.SEND_EMAIL:
            frontmatter += f"""recipient: {self.recipient}
subject: {self.subject}
"""
            if self.cc:
                frontmatter += f"cc: {self.cc}\n"
            if self.bcc:
                frontmatter += f"bcc: {self.bcc}\n"

        elif self.action_type == ActionType.POST_LINKEDIN:
            if self.post_url:
                frontmatter += f"post_url: {self.post_url}\n"

        elif self.action_type == ActionType.SEND_WHATSAPP:
            if self.whatsapp_recipient:
                frontmatter += f"whatsapp_recipient: {self.whatsapp_recipient}\n"

        # Add approval metadata if present
        if self.approved_at:
            frontmatter += f"""approved_at: {self.approved_at.isoformat()}
approved_by: {self.approved_by}
"""

        if self.rejected_at:
            frontmatter += f"""rejected_at: {self.rejected_at.isoformat()}
rejected_by: {self.rejected_by}
rejection_reason: {self.rejection_reason}
"""

        if self.entry_id:
            frontmatter += f"entry_id: {self.entry_id}\n"

        frontmatter += "---\n\n"

        # Build body based on action type
        if self.action_type == ActionType.SEND_EMAIL:
            body = f"""# Approval Request: Email

## Email Details

**To:** {self.recipient}
**Subject:** {self.subject}
"""
            if self.cc:
                body += f"**CC:** {self.cc}\n"
            if self.bcc:
                body += f"**BCC:** {self.bcc}\n"

            body += f"""
## Body

{self.body}

## Risk Assessment

**Risk Level**: {self.risk_level.value}
**Priority**: {self.priority.value}

## Approval Instructions

To approve: Move to Approved/ folder
To reject: Add rejection_reason to frontmatter and move to Rejected/ folder
"""

        elif self.action_type == ActionType.POST_LINKEDIN:
            body = f"""# Approval Request: LinkedIn Post

## Post Content

{self.post_content}

## Risk Assessment

**Risk Level**: {self.risk_level.value}
**Priority**: {self.priority.value}
"""

        elif self.action_type == ActionType.SEND_WHATSAPP:
            body = f"""# Approval Request: WhatsApp Message

## Message Details

**To:** {self.whatsapp_recipient}

## Message

{self.whatsapp_message}

## Risk Assessment

**Risk Level**: {self.risk_level.value}
**Priority**: {self.priority.value}
"""

        else:
            body = f"""# Approval Request

**Action Type**: {self.action_type.value}
**Priority**: {self.priority.value}
**Risk Level**: {self.risk_level.value}
"""

        return frontmatter + body


# ============================================================================
# PLAN MODEL - Created by skills
# ============================================================================

class Plan(BaseModel):
    """
    Action plan created by /needs-action-triage skill.
    Stored in Plans/ folder.
    """

    type: Literal["action_plan"] = "action_plan"
    source: Literal["EMAIL", "FILE", "MANUAL", "LINKEDIN", "WHATSAPP"]
    created: datetime
    priority: Priority
    status: Status
    original_file: str
    requires_approval: bool = False

    # Plan content (stored in markdown body, not frontmatter)
    title: Optional[str] = None
    analysis: Optional[str] = None
    recommended_actions: Optional[list[str]] = None
    questions: Optional[list[str]] = None
    done_condition: Optional[str] = None


# ============================================================================
# EXECUTION RESULT MODEL - Returned by MCP servers
# ============================================================================

class ExecutionResult(BaseModel):
    """
    Result of executing an action via MCP server.
    Used internally by orchestrator.
    """

    success: bool
    message_id: Optional[str] = None
    error: Optional[str] = None
    timestamp: str
    execution_time: float = 0.0
    backend_used: Optional[str] = None
